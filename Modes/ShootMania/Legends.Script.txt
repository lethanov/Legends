/****************************************
*	Legends 4v4 Competition title		*
*	Author:		Platernity				*
*	Contact:	platernity@hotmail.fr	*
****************************************/

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"LegendsArena"
#Const	Version				"1.0"



/* INCLUDES */
#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/Victory.Script.txt" as Victory
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WarmUpSimple.Script.txt" as WarmUp

/* SETTINGS */
#Setting	S_AttackTimeLimit			10		as _("Attack time limit")
#Setting	S_CaptureTimeLimit			15		as _("Capture time limit")
#Setting	S_CaptureTime				1.5		as _("Time to capture pole")
#Setting	S_WarmupTime				90		as _("Warmup duration")
#Setting	S_PointGapToWin				2		as _("Point gap to win map")
#Setting	S_PointLimitToWin			9		as _("Point limit to win map")
#Setting 	S_PointLimitDecisiveRound	15		as _("Decisive point limit")
#Setting 	S_TimeBetweenRounds			2.		as _("Time between Rounds")
#Setting 	S_UsePlayerClublinks		True	as _("Use player clublinks")
#Setting 	S_UseLaserVsBullets			True	as _("Use laser vs rockets")
#Setting	S_UseAmmoBonusOnHit			True	as _("Use Ammo reload on hit")
#Setting 	S_AttackerPingTime			3		as _("Attacker ping time on hit")
#Setting 	S_DefenderRespawnTime		5		as _("Defender respawn time on hit")
#Setting	S_FriendlyFire				False	as _("Friendly fire")

//* CONSTANTS */
#Const Description _("TYPE: Team versus Team (4 vs 4)\nOBJECTIVE:\nOne attacker plays against three defenders on each side. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nThe teams get 1 point for a successfull attack and 1 point for a successfull defence. First team to reach score limit win the map.")
#Const	C_PlayerNeeded	1 		//Number of players needed to start match
#Const	C_NoWarmUp		False	//For testing purposes only
#Const	C_UseBots		True	//For testing purposes only
#Const	C_AttackerAmmoGain			1.0			// Attacker ammunition gain rate
#Const	C_DefenderAmmoGain			1.0			// Defender ammunition gain rate
#Const	C_AttackerArmor				3			// Attacker armor
#Const	C_DefenderArmor				1			// Defender armor
#Const	C_BigMessageTime			1500		// Time BigMessage stay
#Const	C_PoleUITime				1000		// Time PoleUI stay
/* GLOBALES */
declare	Boolean G_CapturingPossible;			// Whether it's possible to capture the goal
declare	Ident[]	G_Team1Players;					// All players from Team 1
declare	Ident[]	G_Team2Players;					// All players from Team 2
declare	Ident[]	G_Team1DefenderPlayers;			// All defender players from Team 1
declare	Ident[]	G_Team2DefenderPlayers;			// All defender players from Team 
declare	Ident	G_Team1AttackingPlayer;			// Attacking player from Team 1
declare	Ident	G_Team2AttackingPlayer;			// Attacking player from Team 2
declare Integer	G_RoundCounter;					// Actual round played
declare Boolean	G_Pole1Captured;
declare Boolean	G_Pole2Captured;
declare Integer[Ident] G_DefenderTimeToBeRespawned;		//List Times for defenders to be respawned

//UI
declare CUILayer LayerScores;
declare CUILayer LayerTeams;
declare CUILayer LayerPosition;
declare CUILayer LayerInformation;
declare CUILayer LayerMarkers;
declare Text[] G_PlayingPlayersLogins;			// Logins of all currently playing players
declare Text G_LongestLaserName;				// Name of longest laser shooter
declare Real G_LongestLaserDist;				// Distance of longest laser shot
declare Integer G_LastBigMessage;				// Time of LastBigMessage
declare Integer G_LastPoleUI;					// Time of LastPoleUI
declare CSmPlayer G_LastPlayerPoleUI;			// Last Player needs PoleUIReset





/*****************************************************
	EXTENSIONS
*****************************************************/
***StartServer***
***
MB_UseSectionRound = True;
InitGameSettings();
***

***StartMap***
***
Mode::Ladder_OpenMatch_All();
InitUI();
InitLayers();
InitValues();
PrepareMatch();
InitBases();
InitPoles();
if(!C_NoWarmUp){
	StartWarmup();
}

***

***StartRound***
***
PrepareRound();
CheckWarmup();
SetTeams();
SetRoles();
SetSpawnsAndPoles();
AnnounceAttackers();
StartPlay();
***

***OnNewPlayer***
***
EditUI(Player);
EditValues();
***

***OnNewSpectator***
***
PrepareUIForSpectator(Spectator);
***

***PlayLoop***
***
UpdateUI();
SpawnPlayers();
HandlePendingEvents();
ActivateGoal();
CheckForCapture();
RespawnDefender();
SetPoints();
***

***EndRound***
***
AttributePoints();
DisplayResults();
CheckMatchEnd();
***

***EndMap***
***
EndMapUI();
AnnounceLegendTeam();
EndMatch();
***

***EndServer***
***
Clean();
***

/*****************************************************
	FUNCTIONS
*****************************************************/
//Other
// Increases score points
Void IncreaseScore(Ident _Id, Integer _Points) {
	if (Players.existskey(_Id) && Players[_Id].Score != Null) {
		Players[_Id].Score.Points += _Points;
	}
}
// Spawn a Player
Void SpawnThePlayer(CSmPlayer Player){
	declare CSmBlockSpawn Spawn;
	foreach(BlockSpawn in BlockSpawns){
		if(BlockSpawn.Base.Clan==Player.CurrentClan){
			Spawn = BlockSpawn;
		}
	}
	
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, 4);
	This.SetPlayerAmmoMax(Player, CSmMode::EWeapon::Arrow, 1);
	
	if (Player.Id == G_Team1AttackingPlayer || Player.Id == G_Team2AttackingPlayer){
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, True);
		Player.AmmoGain = C_AttackerAmmoGain;
		Player.ArmorMax = C_AttackerArmor*100;
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}else{
		This.SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, True);
		Player.AmmoGain = C_DefenderAmmoGain;
		Player.ArmorMax = C_DefenderArmor*100;
		SM::SpawnPlayer(Player, Player.CurrentClan, Spawn, StartTime);
		//SpawnPlayer(Player, Player.CurrentClan, Player.ArmorMax, Spawn, StartTime);
		return;
	}
}
// Get region of users zone path

Text GetRegion(CUser _User) {
	if (_User == Null) {
		return "";
	}
	declare ZonePath = "";
	if (_User.ZonePath != "") {
		declare ExplodeZonePath = TextLib::Split("|", _User.ZonePath);
		if (ExplodeZonePath.existskey(1)) {
			ZonePath = ExplodeZonePath[1];
		}
	}
	if (ZonePath == "") {
		ZonePath = "Other";
	}
	return ZonePath;
}
// Create markers layer manialink
Text GetMarkersLayerManialink() {
	declare Size = 8.0;
	declare SizeFactor = 9.0/16.0;
	
	declare Manialink = "";
	foreach (Pole in BlockPoles) {
		Manialink ^= """
			<frame id="Pole_Marker{{{Pole.Id}}}" hidden="1">
				<quad sizen="{{{Size*SizeFactor}}} {{{Size}}}" image="file://Media/Manialinks/Shootmania/Common/spawn.dds" halign="center" valign="center"/>
			</frame>""";
	}
	return Manialink;
}

//StartServer
Void InitGameSettings() {
UseClans = True;
UseForcedClans = True;
UseLaserVsBullets = S_UseLaserVsBullets;
UIManager.UIAll.NoticesFilter_HideMapWarning = True;
SM::SetupDefaultVisibility();
SpawnScreen::CreateRules("Legends", Description, False);

// Scores table
LayerScores <=> UIManager.UILayerCreate();
LayerScores.Type = CUILayer::EUILayerType::ScoresTable;
UIManager.UIAll.UILayers.add(LayerScores);
// Teams layer
LayerTeams <=> UIManager.UILayerCreate();
Interface::SetLayerTeams(LayerTeams);
UIManager.UIAll.UILayers.add(LayerTeams);
// Position layer
LayerPosition <=> UIManager.UILayerCreate();
Interface::SetLayerPosition(LayerPosition);
// Match information layer
LayerInformation <=> UIManager.UILayerCreate();
//LayerInformation.ManialinkPage = GetLayerInformation();
UIManager.UIAll.UILayers.add(LayerInformation);
// Markers layer
LayerMarkers <=> UIManager.UILayerCreate();
LayerMarkers.Type = CUILayer::EUILayerType::Markers;
LayerMarkers.ManialinkPage = GetMarkersLayerManialink();
UIManager.UIAll.UILayers.add(LayerMarkers);

}
//StartMap
Void InitUI() {
UIManager.UIAll.BigMessage = "";
G_LastBigMessage=0;
UIManager.UIAll.StatusMessage = "";
UIManager.UIAll.ScoreTableOnlyManialink = True;

}
Void InitLayers() {
// Layers
LayerScores.IsVisible = True;
LayerTeams.IsVisible = True;
LayerInformation.IsVisible = True;
LayerMarkers.IsVisible = True;
//LayerScores.ManialinkPage = GetScoresTable();
}
Void InitValues() {
G_RoundCounter=0;
UseAmmoBonusOnHit = S_UseAmmoBonusOnHit;
}
Void PrepareMatch() {
Score::MatchBegin();
Victory::MatchBegin();

}
Void InitBases() {
	declare Integer clan1;
	declare Integer clan2;
	
	if(G_RoundCounter%2==0){
		clan1=1;
		clan2=2;
	}else{
		clan1=2;
		clan2=1;
	}
	
	foreach (Spawn in BlockSpawns) {
		if(Spawn.Order==1){
			Spawn.Base.Clan=clan1;
			Spawn.Base.IsActive = True;
		}else if(Spawn.Order==2){
			Spawn.Base.Clan=clan2;
			Spawn.Base.IsActive = True;
		}else{
			log("no spawn found");
		}
	}
	
	foreach (Pole in BlockPoles){
		if(Pole.Order==1){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan1;
			Pole.Gauge.Clan = clan1;
		}else if(Pole.Order==2){
			Pole.Gauge.ValueReal = 0.0;
			Pole.Base.Clan = clan2;
			Pole.Gauge.Clan = clan2;
		}
		Pole.Gauge.Speed=0;
	}
}

Void InitPoles() {
foreach (Pole in BlockPoles){
	Pole.Gauge.Max = MathLib::NearestInteger(S_CaptureTime * 1000);
	log(Pole.Gauge.Max);
}

}
Void StartWarmup() {
	log("warmup");
	UseClans = True;
	WarmUp::Initialize(15);
	WarmUp::SetMinimumPlayersNumber(C_PlayerNeeded);
	if(C_UseBots){
		log(AllPlayers.count);
		Users_SetNbFakeUsers(3,4);
	}
	WarmUp::Start();
	
}

//StartRound
Void InitRoundValues(){
	StartTime = Now+3500;
	EndTime = StartTime+(S_AttackTimeLimit+S_CaptureTimeLimit)*1000;
	UIManager.UIAll.CountdownEndTime=StartTime+45*1000;
	G_CapturingPossible = False;
	G_Pole1Captured = False;
	G_Pole2Captured = False;
	G_DefenderTimeToBeRespawned.clear();
}
Void PrepareRound() {
SM::UnspawnAllPlayers();
Score::RoundBegin();
Victory::RoundBegin();

}

Void CheckWarmup() {
if (PlayersNbTotal < C_PlayerNeeded) {
	StartWarmup();
}

}
Void SetTeams() {
	G_Team1Players.clear();
	G_Team2Players.clear();
	foreach(Player in Players){
	if(Player.CurrentClan==1){
		G_Team1Players.add(Player.Id);	
	}else if(Player.CurrentClan==2){
		G_Team2Players.add(Player.Id);
	}
	
}

}
Void SetRoles() {
//Team1
G_Team1DefenderPlayers.clear();
G_Team1AttackingPlayer=G_Team1Players[3-G_RoundCounter%4];
foreach(PlayerId in G_Team1Players){
	if(PlayerId!=G_Team1AttackingPlayer){
		G_Team1DefenderPlayers.add(PlayerId);
	}
}
//Team2

G_Team2DefenderPlayers.clear();
G_Team2AttackingPlayer=G_Team2Players[3-G_RoundCounter%4];
foreach(PlayerId in G_Team2Players){
	if(PlayerId!=G_Team2AttackingPlayer){
		G_Team2DefenderPlayers.add(PlayerId);
	}
}

}
Void SetSpawnsAndPoles() {
	InitBases();
}
Void AnnounceAttackers() {
UIManager.UIAll.BigMessage = """$<{{{Players[G_Team1AttackingPlayer].Name}}}$> VS $<{{{Players[G_Team2AttackingPlayer].Name}}}$>""";
UIManager.UIAll.SendNotice("",
		CUIConfig::ENoticeLevel::MapInfo, Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartRound, 0);
G_LastBigMessage = Now;
}
Void StartPlay() {
	
	log("startRound");
	InitRoundValues();
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
}
//OnNewPlayer
Void EditUI(CSmPlayer Player) {
declare UI <=> UIManager.GetUI(Player);
if (UI != Null) {
	UI.UILayers.clear();
	UI.UILayers.add(LayerPosition);
}
}
Void EditValues() {
}
//OnNewSpectator
Void PrepareUIForSpectator(CSmPlayer Spectator) {
// Prepare UI for the new spectator
declare UI <=> UIManager.GetUI(Spectator);
if (UI != Null) {
	UI.UILayers.clear();
	
	// Spectating
	UI.SpectatorForcedClan = -1;
}
}
//PlayLoop
Void UpdateUI(){
	//Big Message Handle
	if (G_LastBigMessage!=0 && Now >= G_LastBigMessage + C_BigMessageTime) {
		log("BigMessage reset");
		G_LastBigMessage=0;
		UIManager.UIAll.BigMessage = "";
	}
	//PoleUI Handle
	if(G_LastPoleUI!=0 && Now >= G_LastPoleUI + C_PoleUITime){
		declare UI <=> UIManager.GetUI(G_LastPlayerPoleUI);
			if (UI != Null) {
				UI.GaugeRatio = -1.;
				UI.GaugeMessage = "";
				UI.GaugeClan = 0;
			}
	}
}
Void SpawnPlayers() {
	if(Now<=StartTime){
	foreach (Player in Players) {
	
	switch (Player.SpawnStatus) {
		case CSmPlayer::ESpawnStatus::NotSpawned: {
			// Player not spawned -> Spawn him!
			//log(Now^" startTime: "^StartTime);
			if (!Player.RequestsSpectate) {
				SpawnThePlayer(Player);
			}
		}
	}
	
	}
	
	}
}
Void HandlePendingEvents() {
foreach (Event in PendingEvents) {
	switch (Event.Type) {
		case CSmModeEvent::EType::OnHit: {
				if (Event.Shooter == Null || Event.Victim == Null) {
					// Discard buggy event
					Discard(Event);
				}else if(Event.Shooter == Event.Victim){
					Discard(Event);
				}else if(Event.Shooter.CurrentClan == Event.Victim.CurrentClan){
					if (S_FriendlyFire) {
							// PassOn team hits
							declare Points = -1;
							Event.ShooterPoints = Points;
							IncreaseScore(Event.Shooter.Id, Points);
							PassOn(Event);
						} else {
							// Discard team hits
							Discard(Event);
						}
			
				}else if(Event.Shooter.CurrentClan != Event.Victim.CurrentClan){
					if(Event.Shooter.Id == G_Team1AttackingPlayer){
						if(Event.Victim.Id == G_Team2AttackingPlayer){
							//Ping Victim
							Discard(Event);
						}else{
							PassOn(Event);
						}
						
					}else if(Event.Shooter.Id == G_Team2AttackingPlayer){
						if(Event.Victim.Id == G_Team1AttackingPlayer){
							//Ping Victim
							Discard(Event);
						}else{
							PassOn(Event);
						}
					}else{
						if(Event.Shooter.CurrentClan == 1){
							if(Event.Victim.Id == G_Team2AttackingPlayer){
								PassOn(Event);
							}else{
								//Def vs Def
								G_DefenderTimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
							}
						}
						if(Event.Shooter.CurrentClan ==2){
							if(Event.Victim.Id == G_Team1AttackingPlayer){
								PassOn(Event);
							}else{
								//Def vs Def
								G_DefenderTimeToBeRespawned[Event.Victim.Id] = Now + S_DefenderRespawnTime*1000;
								PassOn(Event);
							}
						}
					}
				}
			}
		case CSmModeEvent::EType::OnArmorEmpty: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnCapture: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnNearMiss: {
				PassOn(Event);
			}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
				PassOn(Event);
			}
		default: {
			PassOn(Event);
		}
	}
}
}
Void ActivateGoal() {
if (Now >= StartTime + S_AttackTimeLimit*1000) {
	if (!G_CapturingPossible) {
		log("Cap time");
		G_CapturingPossible = True;
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
		UIManager.UIAll.BigMessageSoundVariant = 0;
		UIManager.UIAll.BigMessage = _("The goal can now be captured.");
		UIManager.UIAll.CountdownEndTime = -1;
		G_LastBigMessage=Now;
	}
}
}
Void CheckForCapture(){
foreach (Pole in BlockPoles) {
	if (G_CapturingPossible) {
		if(Pole.Sector.PlayersIds.count > 0){
			foreach(PlayerId in Pole.Sector.PlayersIds){
			
				if(Pole.Gauge.Clan == 1 && PlayerId == G_Team1AttackingPlayer){
					declare UI <=> UIManager.GetUI(Players[PlayerId]);
					if (UI != Null) {
						UI.GaugeRatio = Pole.Gauge.ValueReal;
						UI.GaugeMessage = MathLib::FloorInteger(Pole.Gauge.ValueReal * 100)^"%";
						UI.GaugeClan = Players[PlayerId].CurrentClan;
					}
					Pole.Gauge.Speed = 1;
				}else if(Pole.Gauge.Clan ==2 && PlayerId == G_Team2AttackingPlayer){
					Pole.Gauge.Speed = 1;
				}
				else{
					Pole.Gauge.Speed=0;
				}
			}
		}else{
			Pole.Gauge.Speed=0;
		}
	}else{
		Pole.Gauge.Speed=0;
	}
}
}
Void RespawnDefender() {
	foreach(PlayerId => Time in G_DefenderTimeToBeRespawned){
	
		if(Time != 0 && Now >= Time){
			SpawnThePlayer(Players[PlayerId]);
			G_DefenderTimeToBeRespawned[PlayerId] = 0;
			
		}
	}
}
Void ResetPoleUI(CSmBlockPole Pole){
	if(Pole.Gauge.Clan == 1){
		G_LastPlayerPoleUI = Players[G_Team1AttackingPlayer];
	}
	else if(Pole.Gauge.Clan == 2){
		G_LastPlayerPoleUI = Players[G_Team2AttackingPlayer];
	}
	G_LastPoleUI=Now;
}
Void team1WonAttack(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = """$<{{{Players[G_Team1AttackingPlayer].Name}}}$> wins the Attack""";
	G_LastBigMessage=Now;
}
Void team2WonAttack(){
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Capture;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.BigMessage = """$<{{{Players[G_Team2AttackingPlayer].Name}}}$> wins the Attack""";
	G_LastBigMessage=Now;
}
Void SetPoints() {
foreach(Pole in BlockPoles){
	if(Pole.Gauge.ValueReal>=1.0){
		if(Pole.Base.Clan == 1){
			if(!G_Pole1Captured){
				G_Pole1Captured=True;
				//Attack successfull
				log("Pole captured");
				ResetPoleUI(Pole);
				team1WonAttack();
				
			}
			
		}
		if(Pole.Base.Clan == 2){
			if(!G_Pole2Captured){
				G_Pole2Captured=True;
				//Attack successfull
				log("Pole captured");
				ResetPoleUI(Pole);
				team2WonAttack();
			}
			
		}
		
	}
}

if (!MB_StopRound && Now>=EndTime) {
	// Round winner found
	MB_StopRound = True;
	foreach(Pole in BlockPoles){
		ResetPoleUI(Pole);
	}
	
}


}

//EndRound
Void AttributePoints() {
	G_RoundCounter+=1;
}
Void DisplayResults() {
}
Void CheckMatchEnd() {
}
//EndMap
Void EndMapUI() {
}
Void AnnounceLegendTeam() {
}
Void EndMatch() {
}
//EndServer
Void Clean() {
}

